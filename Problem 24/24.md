# Prime Number Finder

This directory contains a C++ program that finds all prime numbers within a specified range using two different methods:

1. **Brute Force Method**: A straightforward approach that checks each number for primality.
2. **Optimal Method**: An efficient approach using the Sieve of Eratosthenes to find prime numbers.

## Code Explanation

### Brute Force Method

```cpp
void PrimeInRangeBrute(int n) {
    for (int i = 2; i <= n; i++) {
        bool isPrime = true;
        for (int j = 2; j <= sqrt(i); j++) {
            if (i % j == 0) {
                isPrime = false;
                break; // No need to check further
            }
        }
        if (isPrime) {
            cout << i << " "; // Print prime number
        }
    }
}
```

- **Logic**:
  - This method iterates through each number from 2 to `n` and checks if it is divisible by any number up to its square root.
  - If a number is found to be prime, it is printed.

- **Time Complexity**: O(nâˆšn), where `n` is the upper limit of the range.
- **Space Complexity**: O(1), as it uses constant space.

### Optimal Method

```cpp
void PrimeInRangeOptimal(int n) {
    vector<bool> isPrime(n + 1, true); // Track prime status
    isPrime[0] = isPrime[1] = false; // 0 and 1 are not prime
    for (int i = 2; i <= sqrt(n); i++) {
        if (isPrime[i]) {
            for (int j = i * i; j <= n; j += i) {
                isPrime[j] = false; // Mark multiples of i as non-prime
            }
        }
    }
    for (int i = 0; i <= n; i++) {
        if (isPrime[i]) {
            cout << i << " "; // Print prime number
        }
    }
}
```

- **Logic**:
  - This method initializes a boolean vector to track the primality of numbers from 0 to `n`.
  - It marks non-prime numbers by iterating over each prime and marking its multiples as non-prime.
  
- **Time Complexity**: O(n log log n), which is much more efficient for large values of `n`.
- **Space Complexity**: O(n), due to the boolean vector used to track prime statuses.

### Main Function

```cpp
int main() {
    int n;
    cout << "Enter the Range: ";
    cin >> n; // Read the range from user
    PrimeInRangeBrute(n); // Call brute force method
    cout << "\n";
    PrimeInRangeOptimal(n); // Call optimal method
    return 0; // Indicate successful execution
}
```

- **Logic**:
  - The program prompts the user to input the upper limit of the range.
  - It first calls the `PrimeInRangeBrute` function and then the `PrimeInRangeOptimal` function to display the prime numbers found by each method.

## Summary

This program provides two methods to find prime numbers in a given range:
1. **Brute Force Method**: A straightforward but less efficient approach.
2. **Optimal Method**: A more efficient approach that minimizes time complexity for larger ranges.

The optimal method is recommended for use in practical applications, especially when dealing with larger datasets.

--- 