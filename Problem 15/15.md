
# Sorting Algorithms

This directory contains C++ implementations of two sorting algorithms:

1. **Bubble Sort**: A simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.
2. **Merge Sort**: A divide-and-conquer algorithm that divides the array into two halves, recursively sorts them, and then merges the sorted halves.

## Code Explanation

### Bubble Sort

```cpp
#include <iostream>
#include <vector>

using namespace std;

// Function to perform Bubble Sort on the given array
void BubbleSort(vector<int>& arr) {
    bool isSorted; // Flag to check if the array is sorted
    int n = arr.size();
    
    // Outer loop for the number of passes
    for (int i = n - 1; i >= 0; i--) {
        isSorted = true; // Assume the array is sorted
        // Inner loop for comparing adjacent elements
        for (int j = 0; j < i; j++) {
            if (arr[j] > arr[j + 1]) { // If elements are in the wrong order
                swap(arr[j], arr[j + 1]); // Swap them
                isSorted = false; // Set the flag to false
            }
        }
        if (isSorted) return; // If no swaps occurred, the array is sorted
    }
}
```

- **Logic**:
  - The algorithm iterates through the array, comparing adjacent elements and swapping them if they are in the wrong order.
  - The process repeats until the array is sorted or no swaps are made in a pass.
  
- **Time Complexity**: 
  - O(nÂ²) for average and worst cases.
  - O(n) for the best case (when the array is already sorted).
- **Space Complexity**: O(1) as it sorts the array in place.

### Merge Sort

```cpp
#include <bits/stdc++.h>

using namespace std;

// Function to merge two sorted subarrays in-place
void Merge(vector<int> &arr, int low, int mid, int high) {
    vector<int> left(mid - low + 1); // Temporary array for left half
    vector<int> right(high - mid);    // Temporary array for right half

    // Copy data to temporary arrays
    copy(arr.begin() + low, arr.begin() + mid + 1, left.begin());
    copy(arr.begin() + mid + 1, arr.begin() + high + 1, right.begin());

    int i = 0, j = 0, k = low;
    
    // Merge the temp arrays back into the original array
    while (i < left.size() && j < right.size()) {
        if (left[i] <= right[j]) {
            arr[k++] = left[i++]; // Copy from left half
        } else {
            arr[k++] = right[j++]; // Copy from right half
        }
    }

    // Copy the remaining elements of left[], if any
    while (i < left.size()) {
        arr[k++] = left[i++];
    }

    // Copy the remaining elements of right[], if any
    while (j < right.size()) {
        arr[k++] = right[j++];
    }
}

// Function to perform Merge Sort on the array
void MergeSort(vector<int> &arr, int low, int high) {
    if (low < high) {
        int mid = (low + high) / 2; // Find the midpoint
        
        // Recursively sort the two halves
        MergeSort(arr, low, mid);
        MergeSort(arr, mid + 1, high);
        
        // Merge the sorted halves
        Merge(arr, low, mid, high);
    }
}
```

- **Logic**:
  - The algorithm recursively divides the array into halves until each half contains a single element.
  - Then, it merges the sorted halves back together in sorted order.

- **Time Complexity**: O(N log N) for all cases.
- **Space Complexity**: O(N) due to the use of temporary arrays for merging.

### Main Function

```cpp
int main() {
    int n;
    cout << "Enter size of array: ";
    cin >> n; // Read the size of the array
    
    vector<int> arr(n); // Declare a vector of size n
    cout << "Enter elements in the array: ";
    for (int i = 0; i < n; i++) {
        cin >> arr[i]; // Input elements into the vector
    }
    
    // Perform Bubble Sort
    BubbleSort(arr);
    
    // Print the sorted array
    cout << "Sorted array using Bubble Sort: ";
    for (const int& elem : arr) {
        cout << elem << " "; // Print the sorted array
    }
    cout << endl;

    // Reset array for Merge Sort
    cout << "Enter elements in the array again for Merge Sort: ";
    for (int i = 0; i < n; i++) {
        cin >> arr[i]; // Input elements into the vector
    }

    // Perform Merge Sort
    MergeSort(arr, 0, n - 1);
    
    // Print the sorted array
    cout << "Sorted array using Merge Sort: ";
    for (const int& elem : arr) {
        cout << elem << " "; // Print the sorted array
    }
    cout << endl;

    return 0; // Return 0 to indicate successful execution
}
```

- **Logic**:
  - The program prompts the user to input the size of the array and the elements.
  - It first calls the `BubbleSort` function to sort the array using Bubble Sort and prints the results.
  - It then calls the `MergeSort` function to sort the array again using Merge Sort and prints the results.

## Summary

This program implements two sorting algorithms, Bubble Sort and Merge Sort, with their respective advantages and use cases. 

- **Bubble Sort**: Simple and easy to understand but inefficient for large datasets.
- **Merge Sort**: More efficient with a guaranteed time complexity of O(N log N), making it suitable for larger datasets.

Feel free to explore and modify the code for learning purposes!

--- 

This README file provides a comprehensive overview of the sorting algorithms implemented in the directory, detailing both methods, including code snippets and complexity analysis. Let me know if you need any more adjustments!