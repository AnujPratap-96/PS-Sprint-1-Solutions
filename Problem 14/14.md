
# Smallest and Largest Element Finder

This directory contains a C++ program that finds the smallest and largest elements in a vector of integers using two different approaches:

1. **Brute Force Approach**: Finds the smallest and largest by sorting the vector.
2. **Optimal Approach**: Finds the smallest and largest in a single pass.

## Code Explanation

### Brute Force Approach

```cpp
pair<int, int> Smallest_Largest(vector<int> arr) {
    sort(arr.begin(), arr.end()); // Sort the array in ascending order
    return {arr[0], arr[arr.size() - 1]}; // Return the first (smallest) and last (largest) elements
}
```

- **Logic**:
  - The brute force method sorts the input array using the `sort` function from the C++ Standard Library.
  - After sorting, the smallest element is at index 0 and the largest element is at the last index of the sorted array.
  
- **Time Complexity**: O(n log n), where `n` is the number of elements in the vector, due to the sorting operation.
- **Space Complexity**: O(1) for the sorting process (in-place sorting).

### Optimal Approach

```cpp
pair<int, int> Largest_Smallest(vector<int> arr) {
    int largest = INT_MIN, smallest = INT_MAX; // Initialize to extreme values
    for (int i = 0; i < arr.size(); i++) {
        if (arr[i] > largest) largest = arr[i]; // Update largest if current element is bigger
        if (arr[i] < smallest) smallest = arr[i]; // Update smallest if current element is smaller
    }
    return {smallest, largest}; // Return the smallest and largest values found
}
```

- **Logic**:
  - This method initializes `largest` to the minimum integer value and `smallest` to the maximum integer value.
  - It iterates through the vector once, updating `largest` and `smallest` based on the elements in the vector.
  - This approach allows finding both the smallest and largest elements in a single pass through the vector.

- **Time Complexity**: O(n), where `n` is the number of elements in the vector.
- **Space Complexity**: O(1), as it uses constant space.

### Main Function

```cpp
int main() {
    int n;
    cout << "Enter the size of Vector: ";
    cin >> n; // Read the size of the vector
    vector<int> arr(n); // Declare a vector of size n

    cout << "Enter the elements of Vector: ";
    for (int i = 0; i < n; i++) cin >> arr[i]; // Input elements into the vector

    cout << "Vector Elements are: ";
    for (auto &num : arr) cout << num << " "; // Print the vector elements
    cout << endl;

    // Call the brute force method and display the result
    pair<int, int> resultBrute = Smallest_Largest(arr);
    cout << "Brute Force - Smallest Element: " << resultBrute.first << ", Largest Element: " << resultBrute.second << endl;

    // Call the optimal method and display the result
    pair<int, int> resultOptimal = Largest_Smallest(arr);
    cout << "Optimal - Smallest Element: " << resultOptimal.first << ", Largest Element: " << resultOptimal.second << endl;

    return 0; // Return 0 to indicate successful execution
}
```

- **Logic**:
  - The program prompts the user to input the size of the vector and the elements.
  - It first calls the `Smallest_Largest` function to find the smallest and largest elements using the brute force method and prints the results.
  - It then calls the `Largest_Smallest` function to find the smallest and largest elements using the optimal method and prints the results.

## Summary

This program finds the smallest and largest elements in a vector using two approaches:
1. **Brute Force Approach**: Sorts the vector and retrieves the smallest and largest elements.
2. **Optimal Approach**: Uses a single pass through the vector to find both elements efficiently.

The optimal approach is preferred in terms of time complexity and efficiency, especially for large datasets.

---

This README file provides a comprehensive overview of the program, detailing both methods used to determine the smallest and largest elements in a vector, including code snippets and complexity analysis.